{% extends "base.html" %}

{% block title %}Redact PDF - Securely Remove Sensitive Information{% endblock %}
{% block ogtitle %}Redact PDF - Securely Remove Sensitive Information{% endblock %}
{% block ogdescription %}Easily redact sensitive information from your PDF documents. Draw over text or images to permanently remove them from your files.{% endblock %}
{% block canonical %}redact-pdf{% endblock %}

{% block content %}
<section class="hero" aria-label="Main banner">
    <div class="hero-content">
        <h1>Redact Your PDF</h1>
        <p class="hero-description">Draw rectangles over sensitive information to permanently remove it from your document.</p>
    </div>
</section>

<section class="tool-section">
    <div class="tool-container">
        <div class="tool-header">
            <div class="tool-icon">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M9 3H5C3.89543 3 3 3.89543 3 5V19C3 20.1046 3.89543 21 5 21H19C20.1046 21 21 20.1046 21 19V15" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M14 3H21V10" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M21 3L12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </div>
            <h2>PDF Redaction Tool</h2>
        </div>
        <p class="tool-description">Upload your PDF and draw rectangles over sensitive information to permanently remove it from your document.</p>
        
        <div class="redact-container">
            <div id="upload-section">
                <div class="file-upload-container" id="drop-area">
                    <label for="file-input" class="file-upload-label">
                        <svg width="40" height="40" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 15V3M12 3L8 7M12 3L16 7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M4 13V18C4 19.1046 4.89543 20 6 20H18C19.1046 20 20 19.1046 20 18V13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                        <span>Drag and drop your PDF here, or click to select</span>
                    </label>
                    <input type="file" id="file-input" accept=".pdf" class="file-upload-input">
                    <p class="file-name" id="file-name-display">No file selected</p>
                    <div class="upload-button-container">
                        <button id="upload-button" class="upload-button" disabled>Upload PDF</button>
                    </div>
                </div>
            </div>
            
            <div id="redaction-section" class="hidden">
                <div class="controls-bar">
                    <div class="control-group">
                        <button id="redaction-mode" class="control-button">Enable Redaction</button>
                        <button id="clear-redactions" class="control-button">Clear All</button>
                    </div>
                    <div class="page-navigation">
                        <button id="prev-page" class="nav-button">Previous</button>
                        <span id="page-info">Page 1 of 1</span>
                        <button id="next-page" class="nav-button">Next</button>
                    </div>
                    <div class="action-group">
                        <button id="apply-redactions" class="cta-button">Apply Redactions & Download</button>
                    </div>
                </div>
                
                <div class="pdf-viewer-container">
                    <div id="pdf-viewer">
                        <canvas id="pdf-canvas"></canvas>
                        <div id="fabric-canvas-container" style="position: absolute; top: 0; left: 0;">
                            <canvas id="redaction-canvas"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<style>
.upload-button-container {
    text-align: center;
    margin-top: 16px;
}

.upload-button {
    background-color: #6366f1;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 4px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    opacity: 0.7;
}

.upload-button:hover:not(:disabled) {
    opacity: 1;
    transform: translateY(-2px);
}

.upload-button:disabled {
    background-color: #a5a6f6;
    cursor: not-allowed;
}
</style>

<script src="{{ url_for('static', filename='js/pdf.min.js') }}"></script>
<script src="{{ url_for('static', filename='js/fabric.min.js') }}"></script>
<script>
    // Set PDF.js worker path
    pdfjsLib.GlobalWorkerOptions.workerSrc = "{{ url_for('static', filename='js/pdf.worker.min.js') }}";
    
    // DOM elements
    const dropArea = document.getElementById('drop-area');
    const fileInput = document.getElementById('file-input');
    const uploadSection = document.getElementById('upload-section');
    const redactionSection = document.getElementById('redaction-section');
    const pdfCanvas = document.getElementById('pdf-canvas');
    const redactionCanvas = document.getElementById('redaction-canvas');
    const redactionModeBtn = document.getElementById('redaction-mode');
    const clearRedactionsBtn = document.getElementById('clear-redactions');
    const applyRedactionsBtn = document.getElementById('apply-redactions');
    const prevPageBtn = document.getElementById('prev-page');
    const nextPageBtn = document.getElementById('next-page');
    const pageInfo = document.getElementById('page-info');
    const pdfViewer = document.getElementById('pdf-viewer');
    const fileNameDisplay = document.getElementById('file-name-display');
    const uploadButton = document.getElementById('upload-button');
    
    // Variables
    let pdfDoc = null;
    let currentPage = 1;
    let totalPages = 0;
    let currentFilename = '';
    let pdfContext = pdfCanvas.getContext('2d');
    let fabricCanvas = null;
    let redactionMode = false;
    let isDrawing = false;
    let currentRect = null;
    let redactions = [];
    let pdfScale = 1.5;
    let pdfViewport = null;
    
    // Event listeners for file upload
    dropArea.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', handleFileChange);
    uploadButton.addEventListener('click', handleFileUpload);
    
    dropArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropArea.classList.add('dragover');
    });
    
    dropArea.addEventListener('dragleave', () => {
        dropArea.classList.remove('dragover');
    });
    
    dropArea.addEventListener('drop', (e) => {
        e.preventDefault();
        dropArea.classList.remove('dragover');
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            fileInput.files = files;
            
            // Trigger change event
            const event = new Event('change', { bubbles: true });
            fileInput.dispatchEvent(event);
        }
    });
    
    // Button event listeners
    redactionModeBtn.addEventListener('click', toggleRedactionMode);
    clearRedactionsBtn.addEventListener('click', clearAllRedactions);
    applyRedactionsBtn.addEventListener('click', applyRedactionsToServer);
    prevPageBtn.addEventListener('click', goToPrevPage);
    nextPageBtn.addEventListener('click', goToNextPage);
    
    // Handle file change
    function handleFileChange(e) {
        const files = e.target.files;
        if (files.length > 0) {
            const file = files[0];
            if (file.type !== 'application/pdf') {
                alert('Please upload a PDF file');
                fileNameDisplay.textContent = 'No file selected';
                uploadButton.disabled = true;
                return;
            }
            fileNameDisplay.textContent = file.name;
            uploadButton.disabled = false;
        } else {
            fileNameDisplay.textContent = 'No file selected';
            uploadButton.disabled = true;
        }
    }
    
    // Handle file upload button click
    function handleFileUpload() {
        const files = fileInput.files;
        if (files.length > 0) {
            const file = files[0];
            if (file.type !== 'application/pdf') {
                alert('Please upload a PDF file');
                return;
            }
            uploadPDF(file);
        }
    }
    
    // Upload PDF to server
    async function uploadPDF(file) {
        const formData = new FormData();
        formData.append('file', file);
        
        try {
            const response = await fetch('/upload-for-redaction', {
                method: 'POST',
                body: formData
            });
            
            const data = await response.json();
            
            if (data.success) {
                currentFilename = data.filename;
                loadPDF(file);
            } else {
                alert(data.error || 'Upload failed');
            }
        } catch (error) {
            console.error('Error uploading file:', error);
            alert('Error uploading file');
        }
    }
    
    // Load PDF using PDF.js
    async function loadPDF(file) {
        const fileReader = new FileReader();
        
        fileReader.onload = async function() {
            const typedArray = new Uint8Array(this.result);
            
            try {
                pdfDoc = await pdfjsLib.getDocument(typedArray).promise;
                totalPages = pdfDoc.numPages;
                
                // Show redaction UI
                uploadSection.classList.add('hidden');
                redactionSection.classList.remove('hidden');
                
                // Render first page
                renderPage(currentPage);
                updatePageInfo();
            } catch (error) {
                console.error('Error loading PDF:', error);
                alert('Error loading PDF');
            }
        };
        
        fileReader.readAsArrayBuffer(file);
    }
    
    // Initialize fabric.js canvas for redaction
    function initFabricCanvas(width, height) {
        // If canvas already exists, dispose it
        if (fabricCanvas) {
            fabricCanvas.dispose();
        }
        
        // Set canvas dimensions
        redactionCanvas.width = width;
        redactionCanvas.height = height;
        
        // Create new fabric canvas
        fabricCanvas = new fabric.Canvas('redaction-canvas', {
            selection: false,
            renderOnAddRemove: true,
            width: width,
            height: height
        });
        
        // Add event listeners for drawing
        fabricCanvas.on('mouse:down', startDrawingRect);
        fabricCanvas.on('mouse:move', updateDrawingRect);
        fabricCanvas.on('mouse:up', endDrawingRect);
        
        // Set initial redaction mode
        toggleRedactionMode();
    }
    
    // Render PDF page
    async function renderPage(pageNum) {
        try {
            const page = await pdfDoc.getPage(pageNum);
            
            // Calculate scale to fit the container width
            const containerWidth = document.querySelector('.pdf-viewer-container').clientWidth - 40; // Subtract padding
            const originalViewport = page.getViewport({ scale: 1 });
            const scale = Math.min(containerWidth / originalViewport.width, pdfScale);
            
            // Create viewport with calculated scale
            pdfViewport = page.getViewport({ scale: scale });
            
            // Set canvas dimensions
            pdfCanvas.width = pdfViewport.width;
            pdfCanvas.height = pdfViewport.height;
            
            // Center the PDF viewer
            pdfViewer.style.width = `${pdfViewport.width}px`;
            pdfViewer.style.height = `${pdfViewport.height}px`;
            pdfViewer.style.margin = '0 auto';
            
            // Initialize fabric canvas with same dimensions
            initFabricCanvas(pdfViewport.width, pdfViewport.height);
            
            // Render PDF page
            const renderContext = {
                canvasContext: pdfContext,
                viewport: pdfViewport
            };
            
            await page.render(renderContext).promise;
            
            // Load any existing redactions for this page
            loadPageRedactions();
            
        } catch (error) {
            console.error('Error rendering page:', error);
        }
    }
    
    // Update page navigation info
    function updatePageInfo() {
        pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
        prevPageBtn.disabled = currentPage <= 1;
        nextPageBtn.disabled = currentPage >= totalPages;
    }
    
    // Redaction rectangle drawing
    function startDrawingRect(o) {
        if (!redactionMode) return;
        
        isDrawing = true;
        const pointer = fabricCanvas.getPointer(o.e);
        
        currentRect = new fabric.Rect({
            left: pointer.x,
            top: pointer.y,
            width: 0,
            height: 0,
            fill: 'rgba(0, 0, 0, 0.5)',
            selectable: true,
            hasControls: true,
            hasBorders: true
        });
        
        fabricCanvas.add(currentRect);
        fabricCanvas.renderAll();
    }
    
    function updateDrawingRect(o) {
        if (!isDrawing || !redactionMode || !currentRect) return;
        
        const pointer = fabricCanvas.getPointer(o.e);
        
        if (pointer.x < currentRect.left) {
            currentRect.set({ left: pointer.x });
        }
        
        if (pointer.y < currentRect.top) {
            currentRect.set({ top: pointer.y });
        }
        
        currentRect.set({
            width: Math.abs(pointer.x - currentRect.left),
            height: Math.abs(pointer.y - currentRect.top)
        });
        
        fabricCanvas.renderAll();
    }
    
    function endDrawingRect() {
        if (!isDrawing || !redactionMode) return;
        
        isDrawing = false;
        
        // Save the redaction rectangle
        if (currentRect && currentRect.width > 5 && currentRect.height > 5) {
            // Store redaction data with scale factor applied
            redactions.push({
                page: currentPage - 1,  // 0-based page index for backend
                x: currentRect.left / pdfViewport.scale,
                y: currentRect.top / pdfViewport.scale,
                width: currentRect.width / pdfViewport.scale,
                height: currentRect.height / pdfViewport.scale
            });
        } else if (currentRect) {
            // Remove too small rectangles
            fabricCanvas.remove(currentRect);
        }
        
        currentRect = null;
        fabricCanvas.renderAll();
    }
    
    // Load redactions for current page
    function loadPageRedactions() {
        fabricCanvas.clear();
        
        // Filter redactions for current page
        const pageRedactions = redactions.filter(r => r.page === currentPage - 1);
        
        // Add rectangles to fabric canvas
        pageRedactions.forEach(redaction => {
            const rect = new fabric.Rect({
                left: redaction.x * pdfViewport.scale,
                top: redaction.y * pdfViewport.scale,
                width: redaction.width * pdfViewport.scale,
                height: redaction.height * pdfViewport.scale,
                fill: 'rgba(0, 0, 0, 0.5)',
                selectable: true,
                hasControls: true,
                hasBorders: true
            });
            
            fabricCanvas.add(rect);
        });
        
        fabricCanvas.renderAll();
    }
    
    // Apply redactions and download PDF
    async function applyRedactionsToServer() {
        try {
            // Update redactions from any modified rectangles on current page
            updateRedactionsFromCanvas();
            
            if (redactions.length === 0) {
                alert('Please add at least one redaction area');
                return;
            }
            
            const response = await fetch('/apply-redactions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    filename: currentFilename,
                    redactions: redactions
                })
            });
            
            const data = await response.json();
            
            if (data.success) {
                // Download the redacted PDF
                window.location.href = `/download/${data.redacted_filename}`;
            } else {
                alert(data.error || 'Redaction failed');
            }
        } catch (error) {
            console.error('Error applying redactions:', error);
            alert('Error applying redactions');
        }
    }
    
    // Update redactions data from canvas (for modified rectangles)
    function updateRedactionsFromCanvas() {
        // Remove current page redactions
        redactions = redactions.filter(r => r.page !== currentPage - 1);
        
        // Add updated redactions from canvas
        fabricCanvas.getObjects().forEach(obj => {
            if (obj.type === 'rect') {
                redactions.push({
                    page: currentPage - 1,
                    x: obj.left / pdfViewport.scale,
                    y: obj.top / pdfViewport.scale,
                    width: obj.width / pdfViewport.scale,
                    height: obj.height / pdfViewport.scale
                });
            }
        });
    }
    
    // Toggle redaction mode
    function toggleRedactionMode() {
        redactionMode = !redactionMode;
        
        if (redactionMode) {
            redactionModeBtn.textContent = 'Disable Redaction';
            redactionModeBtn.classList.add('active');
            fabricCanvas.selection = false;
        } else {
            redactionModeBtn.textContent = 'Enable Redaction';
            redactionModeBtn.classList.remove('active');
            fabricCanvas.selection = true;
        }
    }
    
    // Clear all redactions
    function clearAllRedactions() {
        fabricCanvas.clear();
        redactions = redactions.filter(r => r.page !== currentPage - 1);
    }
    
    // Page navigation
    function goToPrevPage() {
        if (currentPage > 1) {
            updateRedactionsFromCanvas();
            currentPage--;
            renderPage(currentPage);
            updatePageInfo();
        }
    }
    
    function goToNextPage() {
        if (currentPage < totalPages) {
            updateRedactionsFromCanvas();
            currentPage++;
            renderPage(currentPage);
            updatePageInfo();
        }
    }
</script>
{% endblock %}